ggplot2::geom_col(...)+
ggplot2::theme_light(...)+
ggplot2::scale_fill_viridis_d(...)+
ggplot2::theme(legend.position = "none",
axis.title = ggplot2::element_text(size = 14), ...)+
ggplot2::labs(x = NULL, ...)
}
plot_bars_coherence(lda, selected_k = 10)
lda %>%
unnest(coherence)
lda %>%
tidyr::unnest(coherence)
lda %>%
tidyr::unnest(coherence) %>%
dplyr::mutate(number = stringr::str_extract(topic, "\\d+"))%>%
dplyr::select(number)
lda %>%
tidyr::unnest(coherence) %>%
dplyr::mutate(number = as.numeric(stringr::str_extract(topic, "\\d+")))%>%
dplyr::select(number)
plot_bars_coherence <- function(lda, selected_k, ...){
lda %>%
dplyr::filter(k == selected_k, ...)%>%
tidyr::unnest(coherence, ...)%>%
dplyr::mutate(number = as.numeric(stringr::str_extract(topic, "\\d+")))%>%
ggplot2::ggplot(ggplot2::aes(x = reorder(topic, number), y = coherence, fill = topic, ...))+
ggplot2::geom_col(...)+
ggplot2::theme_light(...)+
ggplot2::scale_fill_viridis_d(...)+
ggplot2::theme(legend.position = "none",
axis.title = ggplot2::element_text(size = 14), ...)+
ggplot2::labs(x = NULL, ...)
}
plot_bars_coherence(lda, selected_k = 10)
plot_bars_coherence(lda, selected_k = 20)
plot_bars_coherence <- function(lda, selected_k, ...){
lda %>%
dplyr::filter(k == selected_k, ...)%>%
tidyr::unnest(coherence, ...)%>%
#extract the number of topics to later order the plots by, so topic_1 > topic_2 not topic_1 > topic_10 when k >= 10
dplyr::mutate(number = as.numeric(stringr::str_extract(topic, "\\d+")))%>%
ggplot2::ggplot(ggplot2::aes(x = reorder(topic, number), y = coherence, fill = topic, ...))+
ggplot2::geom_col(...)+
ggplot2::theme_light(...)+
ggplot2::scale_fill_viridis_d(...)+
ggplot2::theme(legend.position = "none",
axis.title = ggplot2::element_text(size = 14), ...)+
ggplot2::labs(x = NULL, ...)
}
plot_bars_coherence(lda, selected_k = 20)
plot_k_coherence(lda)
#' Scree plot for topic coherence analysis
#'
#' @param lda Latent Dirichlet Allocation object
#'
#' @return ggplot2 object
#' @export
#'
plot_k_coherence <- function(lda){
coherence <- lda %>%
tidyr::unnest(coherence) %>%
dplyr::group_by(k) %>%
dplyr::summarise(coherence = mean(coherence),
median = median(coherence))
coherence %>%
ggplot2::ggplot(ggplot2::aes(x = k, y = coherence))+
ggplot2::geom_line()+
ggplot2::geom_line(aes(x = k, y = median, color = "midnightblue"))+
ggplot2::geom_point()+
ggplot2::theme_light()+
ggplot2::scale_x_continuous(breaks = unique(coherence$k))
}
plot_k_coherence(lda)
plot_bars_coherence(lda, selected_k = 20)
#' Scree plot for topic coherence analysis
#'
#' @param lda Latent Dirichlet Allocation object
#'
#' @return ggplot2 object
#' @export
#'
plot_k_coherence <- function(lda){
coherence <- lda %>%
tidyr::unnest(coherence) %>%
dplyr::group_by(k) %>%
dplyr::summarise(coherence = mean(coherence),
median = median(coherence))
coherence %>%
ggplot2::ggplot(ggplot2::aes(x = k, y = coherence))+
ggplot2::geom_line()+
ggplot2::geom_line(ggplot2::aes(x = k, y = median, color = "midnightblue"))+
ggplot2::geom_point()+
ggplot2::theme_light()+
ggplot2::scale_x_continuous(breaks = unique(coherence$k))
}
plot_k_coherence(lda)
#' Scree plot for topic coherence analysis
#'
#' @param lda Latent Dirichlet Allocation object
#'
#' @return ggplot2 object
#' @export
#'
plot_k_coherence <- function(lda){
coherence <- lda %>%
tidyr::unnest(coherence) %>%
dplyr::group_by(k) %>%
dplyr::summarise(coherence = mean(coherence))
coherence %>%
ggplot2::ggplot(ggplot2::aes(x = k, y = coherence))+
ggplot2::geom_line()+
ggplot2::geom_point()+
ggplot2::theme_light()+
ggplot2::scale_x_continuous(breaks = unique(coherence$k))
}
plot_bars_coherence(lda, selected_k = 10)
rm(listls())
rm(list=ls())
doucment()
library(devtools)
library(roxygen2)
check()
document()
check()
use_package("stats")
document()
check()
document()
check()
use_r("par_fit_LDAs")
use_package("purrr")
use_package("future")
use_package("topicmodels")
use_package("Matrix")
use_package("generics")
use_package("textmineR")
document()
check()
use_package("furrr")
document()
check()
data <- readr::read_csv("~/Documents_local/segmentr_shiny/data/shiny_test_one.csv")
dtms <- SegmentR::make_DTMs(data, mention_content, min_freq = c(5, 10, 15))
par_fit_LDAs(dtms, k_opts = 4)
rm(list=ls())
document()
check()
git checkout https://github.com/jpcompartir/JPackage.git/playing
git branch new_funcs
git status
library(JPackage)
library(dplyr)
library(ggplot2)
library(devtools)
library(roxygen2)
check()
use_r("tidy_huggingface_zero_shot")
document()
check()
?row_number
document()
document()
check()
use_r("reshape_huggingface_output")
use_r("huggingface_quick_clean")
document()
check()
document()
check()
library(JPackage)
library(devtools)
library(roxygen2)
use_r('percent_summ')
percent_summ <- function(df, var){
df %>%
dplyr::count({{var}})%>%
dplyr::mutate(percent = 100 * n / sum(n))
}
x <- tibble(var = c("posiitve", "negative", "neutral", "negative", "positive", "negative", "positive",
"negative"))
x <- tibble::tibble(var = c("posiitve", "negative", "neutral", "negative", "positive", "negative", "positive",
"negative"))
percent_summ <- function(df, var){
df %>%
dplyr::count({{var}})%>%
dplyr::mutate(percent = 100 * n / sum(n))
}
percent_summ(x, var)
percent_summ <- function(df, var){
counts <- dplyr::count(df, {{var}})
dplyr::mutate(counts, percent = 100 * n / sum(n))
}
percent_summ(x, var)
document()
check()
rm(percent_summ)
document()
check()
globalVariables(c( "n", "doc","sub_id", "scores","label","freq_cutoff", "dtm", "alpha", "delta", "iter", "n_terms", "n_docs","k", "coherence", "topic","text", "permalink", "tone" ,"mention_content", "n_gram", "count", "ngram", "df", "data","pattern", "before", "after"))
document()
check()
x <- tibble(var = c("posiitve", "negative", "neutral", "negative", "positive", "negative", "positive"),
two = c("lol", "hey", "ho", "hey", "how", "do", "hi", "hey"),
colours = c("red", "blue", "red", "green", "orange", "pink", "blue", "green"))
x <- tibble::tibble(var = c("posiitve", "negative", "neutral", "negative", "positive", "negative", "positive"),
two = c("lol", "hey", "ho", "hey", "how", "do", "hi", "hey"),
colours = c("red", "blue", "red", "green", "orange", "pink", "blue", "green"))
x <- tibble::tibble(var = c("posiitve", "negative", "neutral", "negative", "positive", "negative", "positive", "positive"),
two = c("lol", "hey", "ho", "hey", "how", "do", "hi", "hey"),
colours = c("red", "blue", "red", "green", "orange", "pink", "blue", "green"))
my_list <- c(var, two, colours)
my_list <- c("var", "two", "colours")
lapply(x, function(x){
x %>%
count(!!!my_list)
})
x %>%
dplyr::count(!!!my_list)
lapply(my_list, function(x){
x %>%
dplyr::count(!!!my_list)
})
lapply(my_list, function(x){
x %>%
dplyr::count(!!!{{my_list}})
})
x %>%
dplyr::count(!!{{my_list}})
x %>%
map(my_list, count)
x %>%
purrr::map(my_list, count)
x %>%
purrr::map(my_list, ~count)
x %>%
purrr::map(my_list, ~count())
x %>%
purrr::map(my_list, ~count(my_list))
x %>%
purrr::map(my_list, ~count({{my_list}}))
x %>% count(var)
library(dplyr)
x %>% count(var)
x %>% count(two)
x %>% count(colours)
my_list[[1]]
!!my_list[[1]]
x %>%
count(!!my_list[[1]])
x %>%
count(my_list[[1]])
x %>%
count(!!my_list[[1]])
x %>%
count({{my_list[[1]]}})
x %>%
count(!!{{my_list[[1]]}})
x %>%
count(sym{{my_list[[1]]}})
my_list <- c(var, two, colours)
lapply(x, function(my_list){
x %>%
count(!!my_list)
})
use_r("count_multiple")
count_multiple <- function(df, my_list){
lapply(df, function(my_list){
df %>%
count(!!my_list)
})
}
x %>%
count(multiple)
x %>%
count_multiple(my_list)
rm(x, my_list)
?!!
rm(count_multiple)
document()
check()
data <- tibble::tibble(sent = c("pos", "neg", "pos"),
color = c("green", "red", "green"),
food = c("sandwich", "pasta", "sandwich"))
#' Count multiple factors
#'
#' @param df Data frame and tibble object
#' @param my_list The variables you want to coiunt
#'
#' @return Summary frames which count your variables
#' @export
#'
count_multiple <- function(df, my_list){
lapply(df, function(my_list){
df %>%
dplyr::count(!!my_list) %>%
dplyr::mutate(percent = 100 * n / sum(n))
})
}
df %>%
count(multiple, c("sent", "color"))
df %>%
count(multiple, my_list = c("sent", "color"))
data <- tibble::tibble(sent = c("pos", "neg", "pos"),
colour = c("green", "red", "green"),
food = c("sandwich", "pasta", "sandwich"))
#' Count multiple factors
#'
#' @param df Data frame and tibble object
#' @param my_list The variables you want to coiunt
#'
#' @return Summary frames which count your variables
#' @export
#'
count_multiple <- function(df, my_list){
lapply(df, function(my_list){
df %>%
dplyr::count(!!my_list) %>%
dplyr::mutate(percent = 100 * n / sum(n))
})
}
df %>%
count_multiple(my_list = c("sent", "color"))
df %>%
count_multiple(my_list = c("sent", "color"))
df %>%
count_multiple(my_list = c(sent, color))
data %>%
count_multiple(my_list = c(sent, color))
rm(data, count_multiple)
document()
check()
library(JPackage)
library(devtools)
library(roxygen2)
document()
check()
document()
check()
document()
library(JPackage)
library(roxygen2)
library(devtools)
load_all()
library(JPackage)
library(JPackage)
library(devtools)
library(roxygen2)
#roxygenise(clean = TRUE)
use_r("umap_shiny")
use_package("shiny")
use_package("DT")
use_package("plotly")
document()
check()
document()
document()
check()
document()
check()
data <- read_csv("~/Google Drive/My Drive/Data Science Project Work/SAMY/genz_mental_health/data/genz_data_final.csv")
library(tidyverse)
data <- read_csv("~/Google Drive/My Drive/Data Science Project Work/SAMY/genz_mental_health/data/genz_data_final.csv")
library(JPackage)
library(devtools)
library(roxygen2)
#roxygenise(clean = TRUE)
library(tidyverse)
data <- read_csv("~/Google Drive/My Drive/Data Science Project Work/SAMY/genz_mental_health/data/genz_data_final.csv")
document()
library(JPackage)
rm(list=ls())
document()
library(JPackage)
data <- read_csv("~/Google Drive/My Drive/Data Science Project Work/SAMY/genz_mental_health/data/genz_data_final.csv")
umap_shiny(data, mention_content, cluster)
system('git stash .')
system("git stage .")
system('git merge main')
library(JPackage)
library(devtools)
library(roxygen2)
#roxygenise(clean = TRUE)
document()
system("git stage .")
use_r("sample_pull")
document()
document()
check()
system("git stage .")
document()
?ifelse
library(devtools)
library(roxygen2)
#roxygenise(clean = TRUE)
load_a()
load_all()
document()
JPackage::sample_pull
use_r("clean_embeddings")
use_r(save_plot_list)
use_r("save_plot_list")
??ggsave
?ggsave
use_r("clean_entities")
document()
use_r("make_top_terms_table")
use_code("plot_top_terms")
use_r("plot_top_terms")
document()
check()
system('git stage .')
library(JPackage)
library(devtools)
library(roxygen2)
#roxygenise(clean = TRUE)
library(pkgdown)
library(pkgbuild)
devtools::github_release()
devtools::build_site()
document()
system("git init .")
pkgdown::build_site(pkg = ".")
system("git stage .")
document()
system("git stage .")
build_site_github_pages()
build_site()
system('git stage .')
system("git remote add origin https://github.com/jpcompartir/JPackage")
git push -u origin master
system("git push -u origin master
")
devtools::build_readme()
devtools::build_readme(path = ".")
use_readme_md()
system('git stage .')
system('git pull ')
system('git checkout main')
system('git merge new_funcs')
system('git push')
system('git pull')
system('git conflict')
system("git --help")
system('git fetch')
system('git checkout new_funcs')
system('git merge new_funcs')
system('git stage .')
system("git remote add origin https://github.com/jpcompartir/JPackage")
system("git set remote origin https://github.com/jpcompartir/JPackage")
system("git reset remote origin https://github.com/jpcompartir/JPackage")
install_github("jpcompartir/JPackage")
use_r("plot_sent_percent")
library(devtools)
library(roxygen2)
#roxygenise(clean = TRUE)
use_r("plot_sent_percent")
document()
use_r("plot_group_vol_time")
#'
#' @param df Data frame or tibble
#' @param group_var grouping variable e.g. country, cluster, topic etc.
#' @param date_var Variable which contains date information (can be datetime too I think)
#' @param unit Time unit fed into lubridate::floor_date e.g. "week", "day", "month", "second"
#' @param nrow How many rows the plot should be shown in
#'
#' @return
#' @export
#'
plot_group_vol_time <- function(df, group, group_var = date, unit = "week", nrow = 2){
date_sym <- rlang::ensym(date_var)
group_sym <- rlang::ensym(group)
df <- df %>% dplyr::mutate(plot_date = lubridate::floor_date(!!date_sym, unit = unit),
facet_var = !!group_sym)
df %>%
dplyr::count(plot_date, facet_var) %>%
ggplot2::ggplot(ggplot2::aes(x = plot_date, y = n, fill = facet_var)) +
ggplot2::geom_col() +
ggplot2::scale_fill_viridis_c() +
ggplot2::theme_minimal() +
ggplot2::scale_x_date(date_breaks = "1 months", date_labels = "%d-%b") +
ggplot2::theme(legend.position = "none",
axis.text.x = element_text(angle = 90)) +
ggplot2::labs(title = "Topic Volume over Time", x = NULL, y = "Number of Posts") +
ggplot2::facet_wrap(~facet_var, nrow = nrow)
}
#'
#' @param df Data frame or tibble
#' @param group_var grouping variable e.g. country, cluster, topic etc.
#' @param date_var Variable which contains date information (can be datetime too I think)
#' @param unit Time unit fed into lubridate::floor_date e.g. "week", "day", "month", "second"
#' @param nrow How many rows the plot should be shown in
#'
#' @return
#' @export
#'
plot_group_vol_time <- function(df, group_var = group, date_var = date, unit = "week", nrow = 2){
date_sym <- rlang::ensym(date_var)
group_sym <- rlang::ensym(group_var)
df <- df %>% dplyr::mutate(plot_date = lubridate::floor_date(!!date_sym, unit = unit),
facet_var = !!group_sym)
df %>%
dplyr::count(plot_date, facet_var) %>%
ggplot2::ggplot(ggplot2::aes(x = plot_date, y = n, fill = facet_var)) +
ggplot2::geom_col() +
ggplot2::scale_fill_viridis_c() +
ggplot2::theme_minimal() +
ggplot2::scale_x_date(date_breaks = "1 months", date_labels = "%d-%b") +
ggplot2::theme(legend.position = "none",
axis.text.x = element_text(angle = 90)) +
ggplot2::labs(title = "Topic Volume over Time", x = NULL, y = "Number of Posts") +
ggplot2::facet_wrap(~facet_var, nrow = nrow)
}
