#'
#' @param df Data frame and tibble object
#' @param ... The variables you want to create individual tables for - unquoted.
#'
#' @return Summary frames which separately count inputted variables and add a percent column
#' @export
#'
count_multiple <- function(df, ...){
df <- df %>%
dplyr::select(...)%>%
tidyr::pivot_longer(cols = everything())
list_names <- df %>% dplyr::distinct(name) %>% dplyr::pull(1)
list_names <- sort(list_names)
list_output <- df %>%
dplyr::group_split(name)%>%
purrr::map(., ~ .x %>%
dplyr::count(value, sort = TRUE) %>%
dplyr::mutate(percent = 100 * n / sum(n)))
names(list_output) <- list_names
return(list_output)
}
ParseR::sprinklr_export %>%
janitor::clean_names() %>%
count_multiple(social_network, sender_screen_name, sentiment)
document()
rm(list=ls())
document()
#' Count multiple factors
#'
#' @param df Data frame and tibble object
#' @param ... The variables you want to create individual tables for - unquoted.
#'
#' @return Summary frames which separately count inputted variables and add a percent column
#' @export
#'
count_multiple <- function(df, ...){
df <- df %>%
dplyr::select(...)%>%
tidyr::pivot_longer(cols = everything())
list_names <- df %>% dplyr::distinct(name) %>% dplyr::pull(1)
list_names <- sort(list_names)
list_output <- df %>%
dplyr::group_split(name)%>%
purrr::map(., ~ .x %>%
dplyr::count(value, sort = TRUE) %>%
dplyr::mutate(percent = 100 * n / sum(n)))
names(list_output) <- list_names
return(list_output)
}
ParseR::sprinklr_export %>%
janitor::clean_names() %>%
count_multiple(social_network, sender_screen_name, sentiment)
#' Count multiple factors
#'
#' @param df Data frame and tibble object
#' @param ... The variables you want to create individual tables for - unquoted.
#'
#' @return Summary frames which separately count inputted variables and add a percent column
#' @export
#'
my_count_multiple <- function(df, ...){
df <- df %>%
dplyr::select(...)%>%
tidyr::pivot_longer(cols = everything())
list_names <- df %>% dplyr::distinct(name) %>% dplyr::pull(1)
list_names <- sort(list_names)
list_output <- df %>%
dplyr::group_split(name)%>%
purrr::map(., ~ .x %>%
dplyr::count(value, sort = TRUE) %>%
dplyr::mutate(percent = 100 * n / sum(n)))
names(list_output) <- list_names
return(list_output)
}
ParseR::sprinklr_export %>%
janitor::clean_names() %>%
my_count_multiple(social_network, sender_screen_name, sentiment)
library(JPackage)
ParseR::sprinklr_export %>%
janitor::clean_names() %>%
JPackage::my_count_multiple(social_network, sender_screen_name, sentiment)
ParseR::sprinklr_export %>%
janitor::clean_names() %>%
JPackage::count_multiple(social_network, sender_screen_name, sentiment)
library(devtools)
library(roxygen2)
#roxygenise(clean = TRUE)
document()
library(JPackage)
library(devtools)
library(roxygen2)
#roxygenise(clean = TRUE)
document()
library(JPackage)
#' Example 1:
#' umap_shiny(data, permalink, sentiment, text_var = message, colour_var = cluster)
#'
#' Example 2:
#' umap_shiny(data, text_var = text, colour_var = sentiment)
#'
#' Example 3:
#' umap_shiny(data, text_var = mention_content, colour_var = entity, x_var = x, y_var = y)
#'
#' }
umap_shiny <- function(data,..., text_var = message, colour_var = cluster,  size = 2,
umap_height = 600, x_var = V1, y_var = V2, type = "scattergl"){
#-----
text_sym <- rlang::ensym(text_var)
colour_sym <- rlang::ensym(colour_var)
data <- dplyr::mutate(data, plot_id = dplyr::row_number(), original_id = dplyr::row_number())
data <- dplyr::relocate(data, plot_id, {{x_var}},{{y_var}}, {{text_var}}, {{colour_var}}, original_id)
data <- dplyr::rename(data, text_var = 4, colour_var = 5)
ui <- shiny::fluidPage(
# shinythemes::themeSelector(),
theme = shinythemes::shinytheme(theme = "superhero"),
shiny::fluidRow(
shiny::column(2, shiny::textInput("remainingName", "File Name", "data_cleaned")),
shiny::column(1, shiny::div(style = "margin-top: 20px;",shiny::downloadButton("downloadAll", "Download All Data", class = "btn btn-success")))
),
shiny::br(),
shiny::fluidRow(
shiny::column(2, shiny::sliderInput( "x1","V1 Range", -100, 100, c(-20, 20))),
shiny::column(2, shiny::sliderInput( "y1","V2 Range", -100, 100, c(-20, 20)))
),
shiny::br(),
shiny::fluidRow(
shiny::column(2, shiny::textInput("Regex", "Pattern to filter",  value = NULL)),
shiny::column(2, shiny::textInput("fileName", "File Name", "mydata")),
shiny::column(2, shiny::div(style = "margin-top: 20px;",shiny::downloadButton("downloadData", "Download Selections", class = "btn btn-success"))),
shiny::column(1, offset = 0, shiny::div(style = "margin-top: 20px;", shiny::actionButton("delete", "Delete selections", class = 'btn-danger'))),
shiny::column(2, offset = 1, shiny::numericInput("n", "Posts shown per page", 10, min = 1, max = 200))
),
shiny::br(),
shiny::fluidRow(
shiny::column(7,
plotly::plotlyOutput("umapPlot")
),
shiny::column(5,
DT::dataTableOutput("highlightedTable")
)
),
)
server <- function(input, output, session){
pattern <- shiny::reactiveVal({})
shiny::observeEvent(input$Regex, {
pattern(input$Regex)
})
#Get the original IDs saved and save an object for later adding selected points to remove
remove_range <- shiny::reactiveValues(
keep_keys = data$original_id,
remove_keys = NULL
)
#Update remove_range's values on delete button press
shiny::observeEvent(input$delete,{
req(length(remove_range$keep_keys) > 0)
remove_range$remove_keys <- selected_range()$key
remove_range$keep_keys <- remove_range$keep_keys[!remove_range$keep_keys %in% remove_range$remove_keys]
})
reactive_data <- shiny::reactive({
data <- data %>%
dplyr::filter(V1 > input$x1[[1]], V1 < input$x1[[2]], V2 > input$y1[[1]], V2 < input$y1[[2]]) %>%
dplyr::filter(!colour_var %in% input$cluster,
original_id %in% remove_range$keep_keys) %>%
dplyr::filter(grepl(pattern(), text_var, ignore.case = TRUE)) %>%
dplyr::mutate(plot_id = dplyr::row_number())
})
output$umapPlot = plotly::renderPlotly({
#cluster can be changed
reactive_data() %>%
plotly::plot_ly(x = ~V1, y = ~V2, type = type, color = ~colour_var,
key = ~original_id,
#make sure mention_content = text variable of your data
text = ~paste("<br> Post:", text_var),
hoverinfo = "text", marker = list(size = size), height = umap_height) %>%
plotly::layout(dragmode = "lasso",
legend= list(itemsizing='constant')) %>%
plotly::event_register(event = "plotly_selected")
})
#Instantiate a reactive value, then update that value dynamically when points are selected.
selected_range <- shiny::reactiveVal({})
shiny::observeEvent(plotly::event_data("plotly_selected"),{
selected_range(plotly::event_data("plotly_selected"))
})
#Now render the data table, selecting all points within our boundaries. Would need to update this for lasso selection.,
output$highlightedTable <- DT::renderDataTable({
#Replacing pointNumber with a key allows for precise showing of points irrespective of variable input type.
key <- selected_range()$key
key <- as.numeric(key)
df <- reactive_data() %>%
dplyr::filter(original_id %in% key) %>%
#Select the columns you want to see from your data
dplyr::select(`ID` = original_id, `Text` = text_var,
`Colour Variable` = colour_var,  ...)
df_copy <<- df
DT::datatable(df, filter = "top", options = list(pageLength = input$n,
dom = '<"top" pif>', autoWidth = FALSE),
style = "bootstrap", rownames = FALSE,
caption = htmltools::tags$caption("Selected Mentions", style="color:white"),
escape = FALSE)
})
output$downloadData <- shiny::downloadHandler(
filename = function() {
paste0(input$fileName, ".csv")
},
content = function(file) {
utils::write.csv(df_copy, file)
}
)
output$downloadAll <- shiny::downloadHandler(
filename = function() {
paste0(input$remainingName, ".csv")
},
content = function(file) {
utils::write.csv(reactive_data(), file)
}
)
}
shiny::shinyApp(ui, server)
}
library(devtools)
library(roxygen2)
#roxygenise(clean = TRUE)
ParseR::sprinklr_export
ParseR::sprinklr_export %>%
janitor::clean_names()
library(JPackage)
library(tidyverse)
library(lubridate)
library(ParseR)
library(SegmentR)
library(HelpR)
library(LimpiaR)
ParseR::sprinklr_export %>%
janitor::clean_names() %>%
umap_shiny(text_var = message, colour_var = social_network)
umap_df <- read_csv("~/Google Drive/My Drive/Data Science Project Work/Microsoft/Project Work/551_sustainability/brand_mentions/551_umap_cluster_sentiment.csv")
umap_df %>%
umap_shiny(text_var = message, colour_var = social_network)
umap_df %>%
umap_shiny(text_var = message_copy, colour_var = social_network)
umap_df %>%
umap_shiny(text_var = message_copy, colour_var = brand)
# test <- read_csv("~/Downloads/test.csv")
# test_all <- read_csv("~/Downloads/test_all_cleaned.csv")
test_two <- read_csv("~/Downloads/test_data_cleaned (1).csv")
test_two
#' Example 1:
#' umap_shiny(data, permalink, sentiment, text_var = message, colour_var = cluster)
#'
#' Example 2:
#' umap_shiny(data, text_var = text, colour_var = sentiment)
#'
#' Example 3:
#' umap_shiny(data, text_var = mention_content, colour_var = entity, x_var = x, y_var = y)
#'
#' }
umap_shiny <- function(data,..., text_var = message, colour_var = cluster,  size = 2,
umap_height = 600, x_var = V1, y_var = V2, type = "scattergl"){
#-----
text_sym <- rlang::ensym(text_var)
colour_sym <- rlang::ensym(colour_var)
data <- dplyr::mutate(data, plot_id = dplyr::row_number(), original_id = dplyr::row_number())
data <- dplyr::relocate(data, plot_id, {{x_var}},{{y_var}}, {{text_var}}, {{colour_var}}, original_id)
data <- dplyr::rename(data, text_var = 4, colour_var = 5)
ui <- shiny::fluidPage(
# shinythemes::themeSelector(),
theme = shinythemes::shinytheme(theme = "superhero"),
shiny::fluidRow(
shiny::column(2, shiny::textInput("remainingName", "File Name", "data_cleaned")),
shiny::column(1, shiny::div(style = "margin-top: 20px;",shiny::downloadButton("downloadAll", "Download All Data", class = "btn btn-success")))
),
shiny::br(),
shiny::fluidRow(
shiny::column(2, shiny::sliderInput( "x1","V1 Range", -100, 100, c(-20, 20))),
shiny::column(2, shiny::sliderInput( "y1","V2 Range", -100, 100, c(-20, 20)))
),
shiny::br(),
shiny::fluidRow(
shiny::column(2, shiny::textInput("Regex", "Pattern to filter",  value = NULL)),
shiny::column(2, shiny::textInput("fileName", "File Name", "mydata")),
shiny::column(2, shiny::div(style = "margin-top: 20px;",shiny::downloadButton("downloadData", "Download Selections", class = "btn btn-success"))),
shiny::column(1, offset = 0, shiny::div(style = "margin-top: 20px;", shiny::actionButton("delete", "Delete selections", class = 'btn-danger'))),
shiny::column(2, offset = 1, shiny::numericInput("n", "Posts shown per page", 10, min = 1, max = 200))
),
shiny::br(),
shiny::fluidRow(
shiny::column(7,
plotly::plotlyOutput("umapPlot")
),
shiny::column(5,
DT::dataTableOutput("highlightedTable")
)
),
)
server <- function(input, output, session){
pattern <- shiny::reactiveVal({})
shiny::observeEvent(input$Regex, {
pattern(input$Regex)
})
#Get the original IDs saved and save an object for later adding selected points to remove
remove_range <- shiny::reactiveValues(
keep_keys = data$original_id,
remove_keys = NULL
)
#Update remove_range's values on delete button press
shiny::observeEvent(input$delete,{
req(length(remove_range$keep_keys) > 0)
remove_range$remove_keys <- selected_range()$key
remove_range$keep_keys <- remove_range$keep_keys[!remove_range$keep_keys %in% remove_range$remove_keys]
})
reactive_data <- shiny::reactive({
data <- data %>%
dplyr::filter(V1 > input$x1[[1]], V1 < input$x1[[2]], V2 > input$y1[[1]], V2 < input$y1[[2]]) %>%
dplyr::filter(!colour_var %in% input$cluster,
original_id %in% remove_range$keep_keys) %>%
dplyr::filter(grepl(pattern(), text_var, ignore.case = TRUE)) %>%
dplyr::mutate(plot_id = dplyr::row_number())
})
output$umapPlot = plotly::renderPlotly({
#cluster can be changed
reactive_data() %>%
plotly::plot_ly(x = ~V1, y = ~V2, type = type, color = ~colour_var,
key = ~original_id,
#make sure mention_content = text variable of your data
text = ~paste("<br> Post:", text_var),
hoverinfo = "text", marker = list(size = size), height = umap_height) %>%
plotly::layout(dragmode = "lasso",
legend= list(itemsizing='constant')) %>%
plotly::event_register(event = "plotly_selected")
})
#Instantiate a reactive value, then update that value dynamically when points are selected.
selected_range <- shiny::reactiveVal({})
shiny::observeEvent(plotly::event_data("plotly_selected"),{
selected_range(plotly::event_data("plotly_selected"))
})
#Now render the data table, selecting all points within our boundaries. Would need to update this for lasso selection.,
output$highlightedTable <- DT::renderDataTable({
#Replacing pointNumber with a key allows for precise showing of points irrespective of variable input type.
key <- selected_range()$key
key <- as.numeric(key)
df_filtered <<- reactive_data() %>%
dplyr::filter(original_id %in% key)
df <- df_filtered %>%
#Select the columns you want to see from your data
dplyr::select(`ID` = original_id, `Text` = text_var,
`Colour Variable` = colour_var,  ...)
DT::datatable(df, filter = "top", options = list(pageLength = input$n,
dom = '<"top" pif>', autoWidth = FALSE),
style = "bootstrap", rownames = FALSE,
caption = htmltools::tags$caption("Selected Mentions", style="color:white"),
escape = FALSE)
})
output$downloadData <- shiny::downloadHandler(
filename = function() {
paste0(input$fileName, ".csv")
},
content = function(file) {
utils::write.csv(df_filtered, file)
}
)
output$downloadAll <- shiny::downloadHandler(
filename = function() {
paste0(input$remainingName, ".csv")
},
content = function(file) {
utils::write.csv(reactive_data(), file)
}
)
}
shiny::shinyApp(ui, server)
}
umap_df %>%
umap_shiny(text_var = message_copy, colour_var = brand)
test <- read_csv("~/Downloads/test.csv")
test
test <- read_csv("~/Downloads/test_selections.csv")
test
document()
rm(list=ls())
document()
umap_shiny(umap_df, text_var = message_copy, colour_var = brand)
f
install.packages("job")
library(job)
library(JPackage)
umap_shiny
use_r("plot_group_wlos_network")
library(devtools)
library(roxygen2)
#roxygenise(clean = TRUE)
use_r("plot_group_wlos_network")
rm(list=ls())
document()
document()
doument()
document()
check()
document()
check(
check()
library(JPackage)
library(JPackage)
library(tidyverse)
library(lubridate)
library(ParseR)
library(SegmentR)
library(HelpR)
library(LimpiaR)
library(tidytext)
library(tm)
setwd("/Volumes/GoogleDrive/.shortcut-targets-by-id/0BwYe_niYW-sLLVdGelZkTHFFSnM/Data Science Project Work/Microsoft/Project Work/551_sustainability")
umap_df <- read_csv("data/551_umap_data.csv") #THIS LINKS TO XXXXXX and has sentiment, entities etc.
umap_df
umap_df %>%
mutate(mention_content = tm::removeWords(mention_content, tm::stopwords(kind = "SMART"))) %>%
calculate_wlos(topic_var = colour_var, text_var = mention_content, nrow = 3, top_n = 25)
umap_df %>%
mutate(mention_content = tm::removeWords(mention_content, tm::stopwords(kind = "SMART"))) %>%
calculate_wlos(topic_var = cluster, text_var = mention_content, nrow = 3, top_n = 25)
umap_df <- umap_df %>%
relocate(date, mention_content, text, classification, cluster, v1, v2) %>%
rename(V1 = v1, V2 = v2)
warnings()
#' @examples
#' \dontrun{
#' Example:
#' df %>%
#'     plot_group_wlos_network(
#'     group_var = sentiment,
#'     text_var = mention_content,
#'     n_terms = 20,
#'     with_ties = FALSE)
#' }
plot_group_wlos_network <- function(data, group_var = brand,
text_var = message, n_terms = 20, top_frequency_terms = 500, with_ties = FALSE){
#Some tidy evaluate variables
group_sym <- rlang::ensym(group_var)
text_sym <- rlang::ensym(text_var)
#Get tokens, count by group then slice n_terms tokens per group
group_tokens <- data %>%
tidytext::unnest_tokens(words, {{text_var}}) %>%
dplyr::group_by({{group_var}}) %>%
dplyr::count(words, sort = TRUE) %>%
dplyr::ungroup() %>%
tidylo::bind_log_odds(set = {{group_var}}, feature = words, n = n) %>%
dplyr::slice_max(order_by = n, n = top_frequency_terms) %>%
dplyr::group_by({{group_var}}) %>%
dplyr::slice_max(order_by = log_odds_weighted, n = n_terms) %>%
dplyr::ungroup()
#Make edges
edges <- group_tokens %>% dplyr::rename(from = {{group_var}},
to = 2)
groups <- unique(edges$from)
#Make a group - group set of rows, wherein the size is going to be large.
group_frame <- tibble::tibble(from = groups, to = groups) %>%
dplyr::mutate(size = 50)
edges <- edges %>% dplyr::bind_rows(group_frame)
nodes <- edges %>%
dplyr::select(from, to) %>%
tidyr::pivot_longer(cols = everything(), values_to = "node_name") %>%
dplyr::distinct(node_name) %>%
dplyr::mutate(size = ifelse(node_name %in% groups, 50, 1))
colour_join <- edges %>% dplyr::select(-c(from, size))
edges <- edges %>%
dplyr::mutate(size = ifelse(to %in% groups, size, 0))
nodes <- nodes %>%
dplyr::left_join(colour_join, by = c("node_name" = "to")) %>%
dplyr::group_by(node_name) %>%
dplyr::mutate(n = mean(n, na.rm = TRUE)) %>%
dplyr::ungroup() %>%
dplyr::mutate(my_colour = ifelse(node_name %in% groups, "GROUP", "NOTGROUP")) %>%
dplyr::distinct(node_name, .keep_all = TRUE) %>%
dplyr::mutate(n = ifelse(is.na(n), 1, n),
n = ifelse(node_name %in% groups, max(n), n))
tidygraph::tbl_graph(nodes = nodes, edges = edges) %>%
ggraph::ggraph(layout = "nicely") +
ggraph::geom_edge_link(edge_alpha = .5, edge_color = "grey70")+
# ggraph::geom_edge_link(edge_alpha = .5, edge_color = "grey70",
#                        aes(edge_width = n))+
ggraph::geom_node_point(aes(size = size, colour = my_colour)) +
shadowtext::geom_shadowtext(ggplot2::aes(label = node_name, x ,y),
size = 3, colour = "black", repel = TRUE,
bg.colour = "white", fontface = "bold",
vjust = 0, bg.r = 0.25)+
ggplot2::theme_void() +
ggplot2::scale_colour_manual(values = c("GROUP" =  "#fde725",
"NOTGROUP" = "#21918c"), guide = "none") +
# ggplot2::scale_colour_viridis_c(guide = "none")+
ggraph::scale_edge_colour_viridis(guide = "none") +
ggplot2::scale_size_continuous(aes(size = size), guide = "none", range = c(0, 10)) #+
# ggraph::scale_edge_width(aes(size = n),range = c(0.5, 4), guide = "none")
}
library(ggtext)
library(devtools)
library(roxygen2)
#roxygenise(clean = TRUE)
check()
use_r("wlo_new_slicer")
document()
document()
library(JPackage)
plot_group_wlos_network
document()
library(devtools)
library(roxygen2)
#roxygenise(clean = TRUE)
use_r("topic_rename")
document()
check()
use_package('shinythemes')
document()
library(JPackage)
