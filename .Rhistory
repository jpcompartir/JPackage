status = "primary",
right = TRUE
),
shiny::textInput("tokenHex", "colour", value ="#0f50d2"),
shiny::uiOutput("tokenTitles"),
shiny::downloadButton(outputId = "saveToken", class = "btn btn-warning",  style = "background: #ff4e00; border-radius: 100px; color: #ffffff; border:none;"),
),
shiny::mainPanel(
shinycssloaders::withSpinner(shiny::plotOutput("tokenPlot", height = plotting_heights, width  = plotting_widths)))
),
),
shiny::br(),
#---- Bigram Tab ----
shiny::tabPanel("Bigram Network", shiny::fluidPage(theme = shinythemes::shinytheme('cosmo'),
gotop::use_gotop()),
shiny::br(),
# Bigram plot ----
shiny::fluidRow(
shiny::column(4,
shiny::p("Below you'll find a bigram network, this network will help you estimate how clean your selected data is. Remember that long and connected chains of words may represent spam or unwanted mentions."),
shiny::br() ,
shiny::p("This bigram network is restricted to a maximum of 5,000 data points for speed and user experience. It is therefore not recommended to be saved or exported. If the data looks clean, download the selection and create the network in the standard way in R/Rstudio"),)
),
shiny::sidebarPanel(width = 2,
shiny::sliderInput("bigramHeight","Height",  min = 100, max = 1200, value = 600, step = 50),
shiny::sliderInput("bigramWidth","Width",  min = 100, max = 1200, value = 800, step = 50),
),
shiny::mainPanel(
shinycssloaders::withSpinner(shiny::plotOutput("bigramPlot",height = plotting_heights,width  = plotting_widths)))
),
)
#---- Server ----
server <- function(input, output, session){
#--- Pattern ----
pattern <- shiny::reactiveVal(value = "",{})
shiny::observeEvent(input$filterPattern, {
pattern(input$Regex)
})
#--- Filter + Reset Pattern ----
shiny::observeEvent(input$reset, {
pattern(input$Regex)
updateTextInput(session, "Regex", value = "")
})
shiny::observeEvent(input$reset, {
pattern("")
})
#--- Delete IDS ----
#Get the original IDs saved and save an object for later adding selected points to remove
remove_range <- shiny::reactiveValues(
keep_keys = data$id_var,
remove_keys = NULL
)
#Update remove_range's values on delete button press
shiny::observeEvent(input$delete,{
req(length(remove_range$keep_keys) > 0)
remove_range$remove_keys <- selected_range()$key
remove_range$keep_keys <- remove_range$keep_keys[!remove_range$keep_keys %in% remove_range$remove_keys]
})
#---- reactive data ---
reactive_data <- shiny::reactive({
data <- data %>%
dplyr::filter(V1 > input$x1[[1]], V1 < input$x1[[2]], V2 > input$y1[[1]], V2 < input$y1[[2]]) %>%
dplyr::filter(!colour_var %in% input$cluster,
id_var %in% remove_range$keep_keys) %>%
dplyr::filter(grepl(input$filterPattern, !!text_sym, ignore.case = TRUE))
})
#--- UMAP Plot ----
output$umapPlot = plotly::renderPlotly({
#cluster can be changed
reactive_data() %>%
plotly::plot_ly(x = ~V1, y = ~V2,
type = type,
color = ~colour_var,
colors = colour_mapping,
key = ~id_var,
#make sure mention_content = text variable of your data
text = ~paste("<br> Post:",text_var),
hoverinfo = "text", marker = list(size = size), height = 600) %>%
plotly::layout(dragmode = "lasso",
legend= list(itemsizing='constant')) %>%
plotly::event_register(event = "plotly_selected")
})
#Instantiate a reactive value, then update that value dynamically when points are selected.
selected_range <- shiny::reactiveVal({})
shiny::observeEvent(plotly::event_data("plotly_selected"),{
selected_range(plotly::event_data("plotly_selected"))
})
#--- Data Table ----
#Now render the data table, selecting all points within our boundaries. Would need to update this for lasso selection.,
output$highlightedTable <- DT::renderDataTable({
#Replacing pointNumber with a key allows for precise showing of points irrespective of variable input type.
key <- selected_range()$key
#Changing to universal_message_id changed the need for this I think?
# key <- as.numeric(key)
df_filtered <<- reactive_data() %>%
#This was trying to find {{id_var}} which had been changed
dplyr::filter(id_var %in% key)
df <- df_filtered %>%
#Select the columns you want to see from your data
dplyr::select(!!text_sym,
`Colour Variable` = colour_var, ..., !!sentiment_sym)
DT::datatable(df, filter = "top", options = list(pageLength = 25,
dom = '<"top" ifp> rt<"bottom"lp>', autoWidth = FALSE), #TODO check adding l worked
style = "bootstrap", rownames = FALSE,
escape = FALSE) #Add escape = False to ensure the HTML clicks work properly
})
#--- Download Handler Data ----
output$downloadData <- shiny::downloadHandler(
filename = function() {
paste0(input$fileName, ".csv")
},
content = function(file) {
utils::write.csv(df_filtered, file)
}
)
output$downloadAll <- shiny::downloadHandler(
filename = function() {
paste0(input$remainingName, ".csv")
},
content = function(file) {
utils::write.csv(reactive_data(), file)
}
)
delayedTokenHex <- shiny::reactive({
input$tokenHex
}) %>%
shiny::debounce(2000)
#--- Reactive plots + Observes ----
shiny::observeEvent(plotly::event_data("plotly_selected"),{
output$sentimentPlot <- shiny::renderPlot({
df_filtered %>%
HelpR::plot_sentiment_distribution(sentiment_var = {{sentiment_var}}) +
HelpR::theme_microsoft_discrete() +
ggplot2::theme(legend.position = "none") +
ggplot2::labs(title = paste0(input$sentimentTitle),
caption = paste0(input$sentimentCaption),
subtitle = paste0(input$sentimentSubtitle),
x = paste0(input$sentimentXlabel),
y = paste0(input$sentimentYlabel))
}, res = 100,
width = function() input$sentimentWidth,
height = function() input$sentimentHeight)
})
#---- Token plot ----
shiny::observeEvent(plotly::event_data("plotly_selected"),{
output$tokenPlot <- shiny::renderPlot({
df_filtered %>%
.plot_tokens_counter(text_var = {{cleaned_text_var}}, top_n = 25, fill = delayedTokenHex()) +
ggplot2::labs(title = paste0(input$tokenTitle),
caption = paste0(input$tokenCaption),
subtitle = paste0(input$tokenSubtitle),
x = paste0(input$tokenXlabel),
y = paste0(input$tokenYlabel)) +
ggplot2::scale_fill_manual(values = input$tokenHex)
}, res = 100,
width = function() input$tokenWidth,
height = function() input$tokenHeight)
})
#---- Volume Plot ----
shiny::observeEvent(plotly::event_data("plotly_selected"),{
output$volumePlot <- shiny::renderPlot({
vol_data <- df_filtered %>%
dplyr::filter(date >= input$dateRange[[1]], date <= input$dateRange[[2]])
vol_plot <- vol_data %>%
.plot_volume_over_time(date = date, unit =  input$dateBreak, fill = input$volumeHex) +
ggplot2::labs(title = paste0(input$volumeTitle),
caption = paste0(input$volumeCaption),
subtitle = paste0(input$volumeSubtitle),
x = paste0(input$volumeXlabel),
y = paste0(input$volumeYlabel))
if(!input$dateSmooth == "none"){
if(input$smoothSe == "FALSE"){
vol_plot <- vol_plot +
ggplot2::geom_smooth(method = input$dateSmooth, se = FALSE, colour = input$smoothColour)
}else {
vol_plot <- vol_plot+
ggplot2::geom_smooth(method = input$dateSmooth, colour = input$smoothColour)
}
}
return(vol_plot)
}, res = 100,
width = function() input$volumeWidth,
height = function() input$volumeHeight)
})
#Render UI plot controls ----
output$smoothControls <- shiny::renderUI({
if(input$dateSmooth != "none"){
shiny::tagList(
shiny::selectInput("smoothSe", "show standard error?", choices = c("TRUE", "FALSE"), selected = "TRUE"),
shiny::textInput("smoothColour", "Smooth colour", value ="#000000")
)
}
})
#Make delete button disappear when nothing selected
output$deleteme <- shiny::renderUI({
if(length(selected_range() > 1)){
shiny::tagList(
shiny::actionButton("delete", "Delete selections", class = 'btn-warning', style = "position: absolute; bottom 7px; right: 7px; background: #ff4e00; border-radius: 100px; color: #ffffff; border:none;")
)
}
})
output$volumeTitles <- shiny::renderUI({
if(input$toggleVolumetitles == "TRUE"){
shiny::tagList(
shiny::textInput(inputId = "volumeTitle", label = "Title",
placeholder = "Write title here...", value = ""),
shiny::textInput(inputId = "volumeSubtitle", label = "Subtitle",
placeholder = "Write subtitle here...", value = ""),
shiny::textInput(inputId = "volumeCaption", label = "Caption",
placeholder = "Write caption here...", value = ""),
shiny::textInput(inputId = "volumeXlabel", label = "X axis title",
placeholder = "Write the x axis title here..."),
shiny::textInput(inputId = "volumeYlabel", label = "Y axis title",
placeholder = "Write the y axis title here")
)
}
})
output$sentimentTitles <- shiny::renderUI({
if(input$toggleSentimenttitles == "TRUE"){
shiny::tagList(
shiny::textInput(inputId = "sentimentTitle", label = "Title",
placeholder = "Write title here...", value = ""),
shiny::textInput(inputId = "sentimentSubtitle", label = "Subtitle",
placeholder = "Write subtitle here...", value = ""),
shiny::textInput(inputId = "sentimentCaption", label = "Caption",
placeholder = "Write caption here...", value = ""),
shiny::textInput(inputId = "sentimentXlabel", label = "X axis title",
placeholder = "Write the x axis title here..."),
shiny::textInput(inputId = "sentimentYlabel", label = "Y axis title",
placeholder = "Write the y axis title here"),
)
}
})
output$tokenTitles <- shiny::renderUI({
if(input$toggleTokentitles == "TRUE"){
shiny::tagList(
shiny::textInput(inputId = "tokenTitle", label = "Title",
placeholder = "Write title here...", value = ""),
shiny::textInput(inputId = "tokenSubtitle", label = "Subtitle",
placeholder = "Write subtitle here...", value = ""),
shiny::textInput(inputId = "tokenCaption", label = "Caption",
placeholder = "Write caption here...", value = ""),
shiny::textInput(inputId = "tokenXlabel", label = "X axis title",
placeholder = "Write the x axis title here..."),
shiny::textInput(inputId = "tokenYlabel", label = "Y axis title",
placeholder = "Write the y axis title here"),
)
}
})
#---- Bigram Plot ----
shiny::observeEvent(plotly::event_data("plotly_selected"),{
output$bigramPlot <- shiny::renderPlot({
if(length(selected_range()) > 1){
if(!length(selected_range()) >= 5000){
bigram <- df_filtered %>%
JPackage::make_bigram_viz(text_var = {{cleaned_text_var}}, clean_text = FALSE, min = 5)
}else{
bigram <- df_filtered %>%
dplyr::sample_n(5000) %>%
JPackage::make_bigram_viz(text_var = {{cleaned_text_var}}, clean_text = FALSE, min = 5)
}
}
bigram
}, res = 100,
width = function() input$bigramWidth,
height = function() input$bigramHeight)
})
#---- Download boxes for plots ----
download_box <- function(exportname, plot) {
shiny::downloadHandler(
filename = function() {
paste(exportname, Sys.Date(), ".png", sep = "")
},
content = function(file) {
ggplot2::ggsave(file, plot = plot, device = "png", width = 8)
}
)
}
output$saveVolume <- download_box("volume_plot", volume_reactive())
output$saveToken <- download_box("token_plot", token_reactive())
output$saveSentiment <- download_box("sentiment_plot", sentiment_reactive())
}
#---- hide app render ----
shiny::shinyApp(ui, server)
}
x %>%
# rename(text = text_var,colour = colour_var) %>%
conversation_landscape(permalink,
id = id_var,
text_var = text_var,
cleaned_text_var = message,
colour_var = colour_var,
sentiment_var = classification,
date_var = date)
document()
library(devtools)
library(roxygen2)
#roxygenise(clean = TRUE)
spam_grams <- function(data, text_var, n_gram = 8, top_n = 1000, min_freq = 5, in_parallel = TRUE){
if(!in_parallel){
grams <- data %>%
tidytext::unnest_tokens(ngram, {{text_var}}, token = "ngrams",
n = n_gram, format = "text")%>%
dplyr::count(ngram, name = "count")%>%
dplyr::slice_max(n = top_n, order_by = count) %>%
dplyr::filter(count >= min_freq)
message("Unnesting ngrams finished")
regex <- paste0(grams$ngram, collapse = "|")
message("Removing spam regex from data")
removed <- data %>% dplyr::filter(stringr::str_detect({{text_var}}, regex))%>%
dplyr::select({{text_var}})
data <- data %>% dplyr::filter(!stringr::str_detect({{text_var}}, regex))
return(list(grams, removed, data, regex))
}
options(future.rng.onMisuse = "ignore")
future::plan(future::multisession(workers = future::availableCores() -1))
text_sym <- rlang::ensym(text_var)
data <- data %>%
dplyr::mutate(.row_id = dplyr::row_number(),
cuts = cut(.row_id, future::availableCores() - 1))
grams <- data %>%
dplyr::group_split(cuts) %>%
furrr::future_map_dfr(~ .x %>%
tidytext::unnest_tokens(ngram,
!!text_sym,
token = "ngrams",
n = n_gram,
format = "text"))
message("Unnesting ngrams finished")
grams <- grams %>%
dplyr::count(ngram, name = "count") %>%
dplyr::slice_max(n = top_n, order_by = count) %>%
dplyr::filter(count >= min_freq)
regex <- grams$ngram
regex <- paste0(regex, collapse = "|")
message("Removing spam regex from data")
removed <- data %>%
dplyr::group_split(cuts) %>%
furrr::future_map_dfr(~ .x %>%
dplyr::filter(stringr::str_detect(!!text_sym, regex)) %>%
dplyr::select(!!text_sym, .row_id))
future::plan(future::sequential())
message("Ending parallel session")
data <- data %>% dplyr::filter(!.row_id %in% removed$.row_id) %>%
dplyr::select(-c(.row_id, cuts))
removed <- dplyr::select(removed, -.row_id)
list(grams,removed,data,regex)
}
library(stringr)
test <- sample(sentences, 10^6, replace = TRUE)
test_small <- sample(sentences, 10^5, replace = TRUE)
test <- tibble::tibble(x = test)
test_small <- tibble::tibble(text = test_small)
test_small
sequential_start <- proc.time()
sequential_result <- spam_grams(test_small, text, min_freq = 2, n_gram = 3, in_parallel =  FALSE)
sequential_end <- proc.time()
sequential_end - sequential_start
spam_grams <- function(data, text_var, n_gram = 8, top_n = 1000, min_freq = 5, in_parallel = TRUE){
if(!in_parallel){
grams <- data %>%
tidytext::unnest_tokens(ngram, {{text_var}}, token = "ngrams",
n = n_gram, format = "text")%>%
dplyr::count(ngram, name = "count")%>%
dplyr::slice_max(n = top_n, order_by = count) %>%
dplyr::filter(count >= min_freq)
message("Unnesting ngrams finished")
regex <- paste0(grams$ngram, collapse = "|")
message("Removing spam regex from data")
removed <- data %>% dplyr::filter(stringr::str_detect({{text_var}}, regex))%>%
dplyr::select({{text_var}})
data <- data %>% dplyr::filter(!stringr::str_detect({{text_var}}, regex))
return(list(grams, removed, data, regex))
}
options(future.rng.onMisuse = "ignore")
future::plan(future::multisession(workers = future::availableCores() -1))
text_sym <- rlang::ensym(text_var)
data <- data %>%
dplyr::mutate(.row_id = dplyr::row_number(),
cuts = cut(.row_id, future::availableCores() - 1))
grams <- data %>%
tidytext::unnest_tokens(ngram, {{text_var}}, token = "ngrams",
n = n_gram, format = "text")%>%
dplyr::count(ngram, name = "count")%>%
dplyr::slice_max(n = top_n, order_by = count) %>%
dplyr::filter(count >= min_freq)
message("Unnesting ngrams finished")
# grams <- data %>%
#   dplyr::group_split(cuts) %>%
#   furrr::future_map_dfr(~ .x %>%
#                           tidytext::unnest_tokens(ngram,
#                                                   !!text_sym,
#                                                   token = "ngrams",
#                                                   n = n_gram,
#                                                   format = "text"))
# message("Unnesting ngrams finished")
# grams <- grams %>%
#   dplyr::count(ngram, name = "count") %>%
#   dplyr::slice_max(n = top_n, order_by = count) %>%
#   dplyr::filter(count >= min_freq)
regex <- grams$ngram
regex <- paste0(regex, collapse = "|")
message("Removing spam regex from data")
removed <- data %>%
dplyr::group_split(cuts) %>%
furrr::future_map_dfr(~ .x %>%
dplyr::filter(stringr::str_detect(!!text_sym, regex)) %>%
dplyr::select(!!text_sym, .row_id))
future::plan(future::sequential())
message("Ending parallel session")
data <- data %>% dplyr::filter(!.row_id %in% removed$.row_id) %>%
dplyr::select(-c(.row_id, cuts))
removed <- dplyr::select(removed, -.row_id)
list(grams,removed,data,regex)
}
parallel_start <- proc.time()
parallel_result <- spam_grams(test_small, text, min_freq = 2, n_gram = 3)
parallel_end <- proc.time()
parallel_end - parallel_start
spam_grams <- function(data, text_var, n_gram = 8, top_n = 1000, min_freq = 5, in_parallel = TRUE){
if(!in_parallel){
grams <- data %>%
tidytext::unnest_tokens(ngram, {{text_var}}, token = "ngrams",
n = n_gram, format = "text")%>%
dplyr::count(ngram, name = "count")%>%
dplyr::slice_max(n = top_n, order_by = count) %>%
dplyr::filter(count >= min_freq)
message("Unnesting ngrams finished")
regex <- paste0(grams$ngram, collapse = "|")
message("Removing spam regex from data")
removed <- data %>% dplyr::filter(stringr::str_detect({{text_var}}, regex))%>%
dplyr::select({{text_var}})
data <- data %>% dplyr::filter(!stringr::str_detect({{text_var}}, regex))
return(list(grams, removed, data, regex))
}
options(future.rng.onMisuse = "ignore")
future::plan(future::multisession(workers = future::availableCores() -1))
text_sym <- rlang::ensym(text_var)
data <- data %>%
dplyr::mutate(.row_id = dplyr::row_number(),
cuts = cut(.row_id, future::availableCores() - 1))
#Note to self - no use parallelising this as it's so fast - actually slows us down.
grams <- data %>%
tidytext::unnest_tokens(ngram, {{text_var}}, token = "ngrams",
n = n_gram, format = "text")%>%
dplyr::count(ngram, name = "count")%>%
dplyr::slice_max(n = top_n, order_by = count) %>%
dplyr::filter(count >= min_freq)
message("Unnesting ngrams finished")
regex <- grams$ngram
regex <- paste0(regex, collapse = "|")
message("Removing spam regex from data")
removed <- data %>%
dplyr::group_split(cuts) %>%
furrr::future_map_dfr(~ .x %>%
dplyr::filter(stringr::str_detect(!!text_sym, regex)) %>%
dplyr::select(!!text_sym, .row_id))
future::plan(future::sequential())
message("Ending parallel session")
data <- data %>% dplyr::filter(!.row_id %in% removed$.row_id) %>%
dplyr::select(-c(.row_id, cuts))
removed <- dplyr::select(removed, -.row_id)
list(grams,removed,data,regex)
}
spam_grams <- function(data, text_var, n_gram = 8, top_n = 1000, min_freq = 5, in_parallel = TRUE){
if(!in_parallel){
grams <- data %>%
tidytext::unnest_tokens(ngram, {{text_var}}, token = "ngrams",
n = n_gram, format = "text")%>%
dplyr::count(ngram, name = "count")%>%
dplyr::slice_max(n = top_n, order_by = count) %>%
dplyr::filter(count >= min_freq)
message("Unnesting ngrams finished")
regex <- paste0(grams$ngram, collapse = "|")
message("Removing spam regex from data")
removed <- data %>% dplyr::filter(stringr::str_detect({{text_var}}, regex))%>%
dplyr::select({{text_var}})
data <- data %>% dplyr::filter(!stringr::str_detect({{text_var}}, regex))
return(list(grams, removed, data, regex))
}
options(future.rng.onMisuse = "ignore")
future::plan(future::multisession(workers = future::availableCores() -1))
text_sym <- rlang::ensym(text_var)
data <- data %>%
dplyr::mutate(.row_id = dplyr::row_number(),
cuts = cut(.row_id, future::availableCores() - 1))
#Note to self - no use parallelising this as it's so fast - actually slows us down.
grams <- data %>%
tidytext::unnest_tokens(ngram, {{text_var}}, token = "ngrams",
n = n_gram, format = "text")%>%
dplyr::count(ngram, name = "count")%>%
dplyr::slice_max(n = top_n, order_by = count) %>%
dplyr::filter(count >= min_freq)
message("Unnesting ngrams finished")
regex <- grams$ngram
regex <- paste0(regex, collapse = "|")
message("Removing spam regex from data")
removed <- data %>%
dplyr::group_split(cuts) %>%
furrr::future_map_dfr(~ .x %>%
dplyr::filter(stringr::str_detect(!!text_sym, regex)) %>%
dplyr::select(!!text_sym, .row_id))
future::plan(future::sequential())
message("Ending parallel session")
data <- data %>% dplyr::filter(!.row_id %in% removed$.row_id) %>%
dplyr::select(-c(.row_id, cuts))
removed <- dplyr::select(removed, -.row_id)
list(grams,removed,data,regex)
}
rm(list=ls())
document()
library(JPackage)
